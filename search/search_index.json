{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#netbox-librenms-plugin","title":"NetBox LibreNMS Plugin","text":""},{"location":"#intro","title":"Intro","text":"<p>The NetBox LibreNMS Plugin enables integration between NetBox and LibreNMS, allowing you to leverage data from both systems. NetBox remains the Source of Truth (SoT) for you network, but this plugin allows you to easily onboard device objects from existing data in LibreNMS. The plugin does not automatically create objects in NetBox to ensure only verified data is used to populate NetBox.</p>"},{"location":"#features","title":"Features","text":"<p>The plugin offers the following key features:</p>"},{"location":"#device-import","title":"Device Import","text":"<p>Search and import devices from LibreNMS into NetBox with comprehensive validation and control:</p> <ul> <li>Filter devices by location, type, OS, hostname, system name, or hardware model</li> <li>Validate import prerequisites (Site, Device Type, Device Role)</li> <li>Smart matching for Sites, Device Types, and Platforms</li> <li>Import as physical Devices or Virtual Machines</li> <li>Bulk import multiple devices</li> <li>Automatic Virtual Chassis creation for stackable switches</li> <li>Background job processing for large device sets</li> </ul> <p>See the Device Import Guide for detailed usage instructions.</p>"},{"location":"#device-field-sync","title":"Device Field Sync","text":"<p>Synchronize device information from LibreNMS to NetBox. The following device fields can be synchronized:</p> <ul> <li>Serial Number (including virtual chassis members)</li> <li>Device Type</li> <li>Platform</li> </ul>"},{"location":"#interface-sync","title":"Interface Sync","text":"<p>Pull interface data from Devices and Virtual Machines from LibreNMS into NetBox. The following interface attributes are synchronized:</p> <ul> <li>Name</li> <li>Description</li> <li>Status (Enabled/Disabled)</li> <li>Type (with custom mapping support)</li> <li>Speed</li> <li>MTU</li> <li>MAC Address</li> </ul> <p>Set custom mappings for interface types to ensure that the correct interface type is used when syncing from LibreNMS to NetBox.</p>"},{"location":"#cable-sync","title":"Cable Sync","text":"<p>Create cable connection in NetBox from LibreNMS links data.</p>"},{"location":"#ip-address-sync","title":"IP Address Sync","text":"<p>Create IP address in NetBox from LibreNMS device IP data.</p>"},{"location":"#add-device-to-librenms-from-netbox","title":"Add device to LibreNMS from Netbox","text":"<ul> <li>Add device to LibreNMS from Netbox device page. SNMP v2c and v3 are supported.</li> </ul>"},{"location":"#site-location-sync","title":"Site &amp; Location Sync","text":"<p>The plugin also supports synchronizing NetBox Sites with LibreNMS locations:</p> <ul> <li>Compare NetBox sites to LibreNMS location data</li> <li>Create LibreNMS locations to match NetBox sites</li> <li>Update existing LibreNMS locations latitude and longitude values based on NetBox data \u26a0\ufe0f (currently not working due to LibreNMS API issue)</li> <li>Sync device site to LibreNMS location</li> </ul>"},{"location":"#screnshotsgifs","title":"Screnshots/GIFs","text":"<p>Screenshots from older plugin version</p>"},{"location":"#site-location-sync_1","title":"Site &amp; Location Sync","text":""},{"location":"#sync-devices-and-interfaces","title":"Sync devices and Interfaces","text":""},{"location":"#virtual-chassis-member-select","title":"Virtual Chassis Member Select","text":""},{"location":"#interface-type-mappings","title":"Interface Type Mappings","text":""},{"location":"#contributing","title":"Contributing","text":"<p>There's more to do! Coding is not my day job so bugs will exist and imporvements will be needed. Contributions are very welcome! I've got more ideas for new features and imporvements but please contribute if you can!</p> <p>Or just share your ideas for the plugin over in discussions.</p>"},{"location":"#compatibility","title":"Compatibility","text":"NetBox Version Plugin Version 4.1 0.2.x - 0.3.5 4.2 - 4.4 0.3.6+"},{"location":"#installing","title":"Installing","text":""},{"location":"#standard-installation","title":"Standard Installation","text":"<p>Activate your virtual environment and install the plugin:</p> <pre><code>source /opt/netbox/venv/bin/activate\n</code></pre> <p>Install with pip:</p> <pre><code>(venv) $ pip install netbox-librenms-plugin\n</code></pre> <p>Add to your <code>local_requirements.txt</code> to ensure it is automatically reinstalled durintg future upgrades.</p> <pre><code> \"netbox-librenms-plugin\" &gt;&gt; /opt/netbox/netbox/local_requirements.txt\n</code></pre>"},{"location":"#docker","title":"Docker","text":"<p>For adding to a NetBox Docker setup see how to create a custom Docker image. the general instructions for using netbox-docker with plugins.</p> <p>Add the plugin to <code>plugin_requirements.txt</code> (netbox-docker):</p> <pre><code># plugin_requirements.txt\nnetbox-librenms-plugin\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#1-enable-the-plugin","title":"1. Enable the Plugin","text":"<p>Enable the plugin in <code>/opt/netbox/netbox/netbox/configuration.py</code>, or if you use netbox-docker, your <code>/configuration/plugins.py</code> file :</p> <pre><code>PLUGINS = [\n    'netbox_librenms_plugin'\n]\n</code></pre>"},{"location":"#2-apply-the-plugin-configuration","title":"2. Apply the plugin configuration","text":"<p>Multi server example:</p> <pre><code>PLUGINS_CONFIG = {\n    'netbox_librenms_plugin': {\n        'servers': {\n            'production': {\n                'display_name': 'Production LibreNMS',\n                'librenms_url': 'https://librenms-prod.example.com',\n                'api_token': 'your_production_token',\n                'cache_timeout': 300,\n                'verify_ssl': True,\n                'interface_name_field': 'ifDescr'\n            },\n            'testing': {\n                'display_name': 'Test LibreNMS',\n                'librenms_url': 'https://librenms-test.example.com',\n                'api_token': 'your_test_token',\n                'cache_timeout': 300,\n                'verify_ssl': False,\n                'interface_name_field': 'ifName'\n            },\n            'development': {\n                'display_name': 'Dev LibreNMS',\n                'librenms_url': 'https://librenms-dev.example.com',\n                'api_token': 'your_dev_token',\n                'cache_timeout': 180,\n                'verify_ssl': False,\n                'interface_name_field': 'ifDescr'\n            }\n        }\n    }\n}\n</code></pre> <p>Or use the original single server confiig example:</p> <pre><code>PLUGINS_CONFIG = {\n    'netbox_librenms_plugin': {\n        'librenms_url': 'https://your-librenms-instance.com',\n        'api_token': 'your_librenms_api_token',\n        'cache_timeout': 300,\n        'verify_ssl': True, # Optional: Change to False if needed,\n        'interface_name_field': 'ifDescr', # Optional: LibreNMS field used for interface name. ifName used as default\n    }\n}\n</code></pre>"},{"location":"#3-apply-database-migrations","title":"3. Apply Database Migrations","text":"<p>Apply database migrations with Netbox <code>manage.py</code>:</p> <pre><code>(venv) $ python manage.py migrate\n</code></pre>"},{"location":"#4-collect-static-files","title":"4. Collect Static Files","text":"<p>The plugin includes static files that need to be collected by NetBox. Run the following command to collect static files:</p> <pre><code>(venv) $ python manage.py collectstatic --no-input\n</code></pre>"},{"location":"#5-restart-netbox","title":"5. Restart Netbox","text":"<p>Restart the Netbox service to apply changes:</p> <pre><code>sudo systemctl restart netbox\n</code></pre>"},{"location":"#6-custom-field","title":"6. Custom Field","text":"<p>It is recommended (but not essential) to add a custom field <code>librenms_id</code> to the Device, Virtual Machine and Interface models in NetBox. Use the following settings:</p> <ul> <li>Object Types:</li> <li>Check dcim &gt; device</li> <li>Check virtualization &gt; virtual machine</li> <li>Check dcim &gt; interface</li> <li>Check virtualization &gt; interfaces (optional)</li> <li>Name: <code>librenms_id</code></li> <li>Label: <code>LibreNMS ID</code></li> <li>Description: (Optional) Add a description like \"LibreNMS ID for LibreNMS Plugin\".</li> <li>Type: Integer</li> <li>Required: Leave unchecked.</li> <li>Default Value: Leave blank.</li> </ul> <p>For more info check out custom field docs</p>"},{"location":"#update","title":"Update","text":"<pre><code>source /opt/netbox/venv/bin/activate\npip install -U netbox-librenms-plugin\npython manage.py migrate\npython manage.py collectstatic --no-input\nsystemctl restart netbox\n</code></pre>"},{"location":"#uninstall","title":"Uninstall","text":"<p>See the instructions for uninstalling plugins.</p>"},{"location":"#credits","title":"Credits","text":"<p>Based on the NetBox plugin tutorial and docs:</p> <ul> <li>demo repository</li> <li>tutorial</li> <li>docs</li> </ul> <p>This package was created with Cookiecutter. Thanks to the <code>netbox-community/cookiecutter-netbox-plugin</code> for the project template.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":""},{"location":"SUMMARY/#table-of-contents","title":"Table of contents","text":"<ul> <li>NetBox LibreNMS Plugin</li> <li>Getting Started</li> <li>Feature Overview</li> <li>Initial Setup</li> <li>Custom Field Setup</li> <li>Multi-Server Setup</li> <li>Suggested Workflow</li> <li>Import Devices</li> <li>Overview</li> <li>Searching for Devices</li> <li>Validation &amp; Configuration</li> <li>Import Settings</li> <li>Background Jobs &amp; Caching</li> <li>Sync &amp; Configuration</li> <li>Virtual Chassis</li> <li>Interface Mappings</li> <li>Development</li> <li>Overview</li> <li>Project Structure</li> <li>Views &amp; Inheritance</li> <li>Mixins</li> <li>Templates</li> <li>Changelog</li> <li>Contributing</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#042-2026-01-16","title":"0.4.2 (2026-01-16)","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Fix device sync not working after update (Issue #199)</li> <li>Fix API endpoints for hostname lookup and port retrieval that were incorrectly changed</li> <li>Fix NameError in get_device_id_by_ip method - correct undefined 'mac_address' variable error (Issue #197)</li> </ul>"},{"location":"changelog/#041-2026-01-12","title":"0.4.1 (2026-01-12)","text":""},{"location":"changelog/#fixes_1","title":"Fixes","text":"<ul> <li>Fix librenms_id custom field to use integer values in import process</li> </ul>"},{"location":"changelog/#040-2026-01-09","title":"0.4.0 (2026-01-09)","text":""},{"location":"changelog/#major-features","title":"Major Features","text":"<ul> <li>LibreNMS Bulk Device Import: Complete workflow for importing devices from LibreNMS with HTMX-based UI, validation, and background job processing</li> <li>Background Job Support: Asynchronous processing for large device imports with real-time status tracking and cancellation</li> <li>Enhanced Caching: Improved caching system with expiration countdown, metadata storage, and multi-server isolation</li> <li> <p>Virtual Chassis Detection: Automatic detection and handling of virtual chassis during import</p> </li> <li> <p>Add hardware and exclude-existing filters to device import</p> </li> <li>Client-side table sorting for import page</li> <li>Active LibreNMS server display on import page</li> <li>Improved logging patterns and documentation</li> <li>Cache management with discard controls</li> <li>Refactored settings page with HTMX (removed fetch-based JavaScript)</li> <li>Enhanced virtual chassis sync device detection logic</li> <li>Better error handling and connection exhaustion prevention</li> </ul>"},{"location":"changelog/#development","title":"Development","text":"<ul> <li>Improved dev container with RQ worker management</li> <li>Comprehensive test coverage for background jobs</li> <li>Enhanced copilot instructions for AI-assisted development</li> <li>Better process management and reload scripts</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Extensive import documentation (overview, process, settings, validation, search)</li> <li>Background job architecture documentation</li> <li>Improved README and workflow guides</li> <li>Virtual chassis usage documentation</li> </ul>"},{"location":"changelog/#0318-2025-11-21","title":"0.3.18 (2025-11-21)","text":""},{"location":"changelog/#improvements","title":"Improvements","text":"<ul> <li>Add all LibreNMS SNMP fields to add device form</li> </ul>"},{"location":"changelog/#0317-2025-10-24","title":"0.3.17 (2025-10-24)","text":""},{"location":"changelog/#improvements_1","title":"Improvements","text":"<ul> <li>Improve device type matching with prioritized matching strategy</li> <li>Centralize device type matching logic in utils.py (DRY principle)</li> <li>Add word boundary detection for more precise substring matches</li> </ul>"},{"location":"changelog/#0316-2025-10-24","title":"0.3.16 (2025-10-24)","text":""},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Add device field synchronization (serial number, device type, platform)</li> <li>Add virtual chassis inventory support with serial assignment to individual members</li> <li>Add VM information display in LibreNMS status card</li> <li>Add bulk interface mapping import functionality</li> </ul>"},{"location":"changelog/#improvements_2","title":"Improvements","text":"<ul> <li>Improve virtual chassis device matching with LibreNMS for devices with VC member suffixes</li> <li>Enhance virtual chassis logic and member selection</li> </ul>"},{"location":"changelog/#development_1","title":"Development","text":"<ul> <li>Add GitHub DevContainer setup for easier development environment</li> </ul>"},{"location":"changelog/#fixes_2","title":"Fixes","text":"<ul> <li>Fix FieldError for librenms_status on device/VM status pages</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Update README with device field sync details</li> <li>Improve virtual chassis documentation</li> <li>Added example Interface Mapping YAML for bulk import</li> </ul>"},{"location":"changelog/#0315-2025-07-12","title":"0.3.15 (2025-07-12)","text":""},{"location":"changelog/#improvements_3","title":"Improvements","text":"<ul> <li>Improve multi-server configuration handling and add connection testing</li> </ul>"},{"location":"changelog/#0314-2025-07-08","title":"0.3.14 (2025-07-08)","text":""},{"location":"changelog/#fixes_3","title":"Fixes","text":"<ul> <li>Filter out invalid IP entries in BaseIPAddressTableView</li> </ul>"},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li>View/Delete NetBox-only (unmatched) interfaces</li> <li>Add multi LibreNMS server configuration support for LibreNMS plugin</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>Add page for multi server configuration instructions and example</li> </ul>"},{"location":"changelog/#0313-2025-0627","title":"0.3.13 (2025-06=27)","text":""},{"location":"changelog/#new-feature","title":"New Feature","text":"<ul> <li>Add support for IPv6 handling in IP address synchronization</li> </ul>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>Add basic development documentation</li> </ul>"},{"location":"changelog/#0312-2025-04-11","title":"0.3.12 (2025-04-11)","text":""},{"location":"changelog/#improvements_4","title":"Improvements","text":"<ul> <li>Add VRF selection support to IP address table and sync</li> <li>Implement single IP address verification and VRF assignment</li> <li>Extend single IP verification to support Virtual Machines</li> </ul>"},{"location":"changelog/#under-the-hood","title":"Under the hood","text":"<ul> <li>Refactor cable and IP address synchronization methods for improved transaction handling</li> <li>Refactor IP address enrichment for improved performance</li> </ul>"},{"location":"changelog/#0311-2025-03-31","title":"0.3.11 (2025-03-31)","text":""},{"location":"changelog/#improvements_5","title":"Improvements","text":"<ul> <li>Enhance remote port enrichment for virtual chassis devices</li> </ul>"},{"location":"changelog/#0310-2025-03-17","title":"0.3.10 (2025-03-17)","text":""},{"location":"changelog/#fixes_4","title":"Fixes","text":"<ul> <li>Fix URL error when no interfaces are selected during sync</li> <li>Add hidden SNMP version field to forms and update sync logic</li> </ul>"},{"location":"changelog/#039-2025-03-14","title":"0.3.9 (2025-03-14)","text":""},{"location":"changelog/#fixes_5","title":"Fixes","text":"<ul> <li>Fix missing add_device_modal.html template and form handling</li> <li>Fix missing interfacetypemapping template</li> </ul>"},{"location":"changelog/#038-2025-03-06","title":"0.3.8 (2025-03-06)","text":""},{"location":"changelog/#fixes_6","title":"Fixes","text":"<ul> <li>Fix cable table error when more than one remote device returned</li> <li>Fix cable table checkboxes controls for virtual chassis devices</li> </ul>"},{"location":"changelog/#improvements_6","title":"Improvements","text":"<ul> <li>Add slug check to Site and Location Sync</li> </ul>"},{"location":"changelog/#037-2025-01-22","title":"0.3.7 (2025-01-22)","text":""},{"location":"changelog/#fixes_7","title":"Fixes","text":"<ul> <li>Fix issue with empty queryset to stop fielderror</li> </ul>"},{"location":"changelog/#improvements_7","title":"Improvements","text":"<ul> <li>Enhance filtering options for devices and virtual machines</li> </ul>"},{"location":"changelog/#under-the-hood_1","title":"Under the hood","text":"<ul> <li>Review and refactor docstrings across all files</li> </ul>"},{"location":"changelog/#036-2025-01-21","title":"0.3.6 (2025-01-21)","text":""},{"location":"changelog/#note","title":"NOTE","text":"<p>Netbox v4.2+ required for this release</p>"},{"location":"changelog/#new-feature_1","title":"New Feature","text":"<ul> <li>New dedicated plugin menu item</li> <li>Add device and VM status pages</li> </ul>"},{"location":"changelog/#fixes_8","title":"Fixes","text":"<ul> <li>Add description to interface mapping page</li> </ul>"},{"location":"changelog/#under-the-hood_2","title":"Under the hood","text":"<ul> <li>Update to use new Mac Address object for Netbox v4.2</li> </ul>"},{"location":"changelog/#035-2025-01-13","title":"0.3.5 (2025-01-13)","text":""},{"location":"changelog/#fixes_9","title":"Fixes","text":"<ul> <li>Fix IP Address table not displaying for Virutal Machines</li> </ul>"},{"location":"changelog/#034-2025-01-08","title":"0.3.4 (2025-01-08)","text":""},{"location":"changelog/#fixes_10","title":"Fixes","text":"<ul> <li>Fix VM Interface table not dispalying</li> </ul>"},{"location":"changelog/#033-2025-01-03","title":"0.3.3 (2025-01-03)","text":""},{"location":"changelog/#new-feature_2","title":"New Feature","text":"<ul> <li>Add IP address synchronization</li> </ul>"},{"location":"changelog/#fixes_11","title":"Fixes","text":"<ul> <li>Refactor librenms_id handling in SyncInterfacesView</li> </ul>"},{"location":"changelog/#under-the-hood_3","title":"Under the hood","text":"<ul> <li>Refactor table.py into separate modules for better maintainability</li> <li>Enhance interface data retrieval efficiency</li> </ul>"},{"location":"changelog/#032-2024-12-16","title":"0.3.2 (2024-12-16)","text":""},{"location":"changelog/#fixes_12","title":"Fixes","text":"<ul> <li>Refactor tab handling for interface and cable views</li> <li>Fix Duplicate ID in SNMP forms</li> <li>Refactor cable link processing and fix CSRF token error.</li> <li>Generate unique base ID for TomSelect components in VCInterfaceTable</li> <li>Add countdown interval variable to initializeCountdown function</li> </ul>"},{"location":"changelog/#031-2024-12-13","title":"0.3.1 (2024-12-13)","text":""},{"location":"changelog/#fixes_13","title":"Fixes","text":"<ul> <li>Fix issue with tab selection not working after sync task</li> <li>Updated interface name field tooltip</li> </ul>"},{"location":"changelog/#030-2024-12-13","title":"0.3.0 (2024-12-13)","text":""},{"location":"changelog/#new-setting","title":"New Setting","text":"<ul> <li>Add <code>interface_name_feild</code> optional setting to allow choice of interface name field used when syncing interface data.</li> <li>Add <code>interface_name_field</code> override in GUI for per device control and flexibility.</li> </ul>"},{"location":"changelog/#improvements_8","title":"Improvements","text":"<ul> <li>Add <code>librenms_id</code> to interface sync table and data sync</li> <li>Use of <code>librenms_id</code> custom field on interface lookup for improved matching in the cables table.</li> <li>Add Pagination support to the cables table.</li> </ul>"},{"location":"changelog/#fixes_14","title":"Fixes","text":"<ul> <li>Fix issue with case sensitive hostname matching</li> </ul>"},{"location":"changelog/#under-the-hood_4","title":"Under the hood","text":"<ul> <li>Refactor views into seperate modules for better maintainability</li> </ul>"},{"location":"changelog/#029-2024-11-30","title":"0.2.9 (2024-11-30)","text":""},{"location":"changelog/#fix-pypi-release","title":"Fix pypi release","text":"<p>Add static include in MANIFEST.in for pypi release</p>"},{"location":"changelog/#028-2024-11-29","title":"0.2.8 (2024-11-29)","text":""},{"location":"changelog/#use-of-custom-field","title":"Use of Custom Field","text":"<p>This release introduces the option of using a custom field <code>librenms_id</code> (integer) to device and virtual machine objects in NetBox. The plugin will work without it but it is recommended for LibreNMS API lookups especially if no primary IP or FQDN available.</p> <p>Note: New static javascript file requires running collectstatic after update</p> <pre><code>(venv) $ python manage.py collectstatic --no-input\n</code></pre>"},{"location":"changelog/#new-features_2","title":"New Features","text":"<ul> <li>Add device to LibreNMS using SNMPv3</li> <li>Create cable connection from LIbreNMS links data31</li> <li>Plugin can now use primary IP, hostname or Primary IP DNS Name to identify device in LibreNMS</li> <li>Exclude specific columns when syncing data</li> <li>Filter interface and cable tables</li> <li>Bulk edit Virtual Chassis members</li> </ul>"},{"location":"changelog/#improvements_9","title":"Improvements","text":"<ul> <li>Add pagination to SiteLocationSyncTable</li> <li>Add site location filtering functionality and update template for search</li> <li>Refactor LibreNMSAPI to enhance device ID retrieval logic and include DNS name handling</li> <li>Enhance cable sync with device ID handling and user guidance modal</li> <li>Add device mismatch check and user feedback</li> <li>Add check for empty MAC address in format_mac_address function</li> <li>Increase API request timeout to 20 seconds</li> <li>Fix dropdown menu size issue on click</li> </ul>"},{"location":"changelog/#under-the-hood_5","title":"Under the hood","text":"<ul> <li>Refactor interface enabled status logic</li> <li>Fix handling of data-enabled attribute in interface table</li> <li>Improve interface mapping logic for speed matchingpull/24</li> <li>Refactor cable context handling and improve data rendering in cable tables</li> <li>Refactor Javascript into single file. Add cable sync filters and countdown timer</li> <li>Refactor device addition and enhance SNMP v3 support</li> </ul>"},{"location":"changelog/#027-2024-11-11","title":"0.2.7 (2024-11-11)","text":""},{"location":"changelog/#whats-changed","title":"What's Changed","text":"<ul> <li>Add new interface table logic to handle virtual chassis member selection</li> <li>Update LibreNMS plugin configuration to allow disabling of SSL verification</li> </ul>"},{"location":"changelog/#interface-name-change","title":"Interface name change","text":"<p>The LibreNMS Sync interface names now use the ifDescr from Librenms. This displays the full interface name to better align with the device type library convention. e.g GigabitEthernet1/0/1 instead of Gig1/0/1.</p>"},{"location":"changelog/#026-2024-10-25","title":"0.2.6 (2024-10-25)","text":""},{"location":"changelog/#new-feature_3","title":"New Feature","text":"<ul> <li>Sync Virtual Machine interfaces</li> </ul>"},{"location":"changelog/#bug-fix","title":"Bug fix","text":"<ul> <li>Pagination bug where page contents would duplicate now fixed.</li> </ul>"},{"location":"changelog/#under-the-hood_6","title":"Under the hood","text":"<ul> <li>Refactoring of views into separate files for better maintainability.</li> <li>Code formatting improvements</li> <li>Remove unused elements</li> </ul>"},{"location":"changelog/#025-2024-10-21","title":"0.2.5 (2024-10-21)","text":"<p>Bug fix release: * Missing commas in LibreNMS api module</p>"},{"location":"changelog/#024-2024-10-21","title":"0.2.4 (2024-10-21)","text":""},{"location":"changelog/#enhancements","title":"Enhancements","text":"<ul> <li>Add mac_address, MTU to interface sync</li> <li>Enable select all and shift click on interface sync page rows, and other improvements</li> <li>Interface mapping now accounts for speed of interface     &gt; Update to Interface mapping modal may require recreation of existing mapping.</li> <li>Updated LibreNMS Sync page layout to prepare for new features</li> </ul>"},{"location":"changelog/#under-the-hood_7","title":"Under the hood","text":"<ul> <li>Refactor all views to be class-based</li> <li>Big refactor of device LibreNMS sync views to make way for new features</li> </ul>"},{"location":"changelog/#023-2024-09-30","title":"0.2.3 (2024-09-30)","text":"<ul> <li>Fix bug where wrong template is used when editing interface mappings</li> <li>Remove unused templates from view</li> </ul>"},{"location":"changelog/#022-2024-09-27","title":"0.2.2 (2024-09-27)","text":"<ul> <li>Fix too many arguments to add_device error</li> </ul>"},{"location":"changelog/#021-2024-09-27","title":"0.2.1 (2024-09-27)","text":"<ul> <li>Fix LibreNMS hardware variable not found</li> <li>Add update_device_field to LibreNMS API</li> <li>Add device location Sync button to device plugin tab</li> <li>Change SNMP community from 'text' to 'password' for privacy</li> </ul>"},{"location":"changelog/#020-2024-09-25","title":"0.2.0 (2024-09-25)","text":"<ul> <li>Update to v0.2.0 of the plugin</li> </ul>"},{"location":"changelog/#011-2024-09-24","title":"0.1.1 (2024-09-24)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>We love your input! We want to make contributing to this project as easy and transparent as possible, whether it's:</p> <ul> <li>Reporting a bug</li> <li>Discussing the current state of the code</li> <li>Submitting a fix</li> <li>Proposing new features</li> <li>Becoming a maintainer</li> </ul>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/bonzo81/netbox-librenms-plugin/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Any details about your local environment that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>NetBox LibreNMS Plugin could always use more documentation, whether as part of the official NetBox LibreNMS Plugin docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/bonzo81/netbox-librenms-plugin/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>netbox-librenms-plugin</code> for local development.</p> <ol> <li>Fork the <code>netbox-librenms-plugin</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>$ git clone git@github.com:&lt;username&gt;/netbox-librenms-plugin.git\n</code></pre> </li> <li> <p>Activate the NetBox virtual environment (see the NetBox documentation under Setting up a Development Environment):</p> <pre><code>$ source /opt/netbox/venv/bin/activate\n</code></pre> </li> <li> <p>Add the plugin to NetBox virtual environment in Develop mode (see Plugins Development):</p> <p>To ease development, it is recommended to go ahead and install the plugin at this point using setuptools' <code>develop</code> mode. This will create symbolic links within your Python environment to the plugin development directory. Call <code>pip</code> from the plugin's root directory with the <code>-e</code> flag:</p> <pre><code>$ pip install -e .\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.10+. Check    https://github.com/bonzo81/netbox-librenms-plugin/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md) and that all tests pass. Then in the github project go to <code>Releases</code> and create a new release with a new tag.  This will automatically upload the release to pypi:</p>"},{"location":"feature_list/","title":"Feature Overview","text":""},{"location":"feature_list/#device-import","title":"Device Import","text":"<ul> <li>Search and discover devices from LibreNMS using flexible filters</li> <li>Validate device prerequisites before import (Site, Device Type, Device Role)</li> <li>Import devices as physical Devices or Virtual Machines</li> <li>Smart matching for Sites, Device Types, and Platforms</li> <li>Bulk import support</li> <li>Automatic Virtual Chassis creation for stackable devices</li> <li>Background job processing for large device sets</li> <li>Duplicate detection to prevent re-importing existing devices</li> </ul>"},{"location":"feature_list/#plugin-settings","title":"Plugin Settings","text":"<ul> <li>Multi-server LibreNMS configuration support</li> <li>Configurable device naming defaults (sysName vs hostname)</li> <li>Domain stripping options during import for cleaner device names</li> <li>Virtual Chassis member naming pattern customization during import</li> </ul>"},{"location":"feature_list/#device","title":"Device","text":"<ul> <li>LibreNMS device identification via:</li> <li>Custom field <code>librenms_id</code> (recommended)</li> <li>Primary IP address</li> <li>Primary IP DNS name</li> <li>Hostname</li> <li>Add device to LibreNMS from netbox via SNMP v2c or v3</li> </ul>"},{"location":"feature_list/#virtual-chassis-support","title":"Virtual Chassis Support","text":"<ul> <li>Automatic VC member selection for each interface</li> <li>Member-specific interface synchronization</li> <li>Bulk member editing capabilities</li> </ul>"},{"location":"feature_list/#interface-sync","title":"Interface Sync","text":"<ul> <li>Create or Update interface in NetBox from LibreNMS interface data</li> <li>Name</li> <li>Description</li> <li>Status (Enabled/Disabled)</li> <li>Type (with custom mapping support)</li> <li>Speed</li> <li>MAC Address</li> <li>MTU</li> <li>Sync all or specific fields</li> </ul>"},{"location":"feature_list/#cable-sync","title":"Cable Sync","text":"<ul> <li>Create Cable connection in NetBox from LibreNMS links data</li> <li>Best results when the custom field <code>librenms_id</code> is populated on interfaces</li> </ul>"},{"location":"feature_list/#ip-address-sync","title":"IP Address Sync","text":"<ul> <li>Create IP address objects in Netbox from LibreNMS device IP data</li> <li>Best results when the custom field <code>librenms_id</code> is populated on interfaces</li> </ul>"},{"location":"feature_list/#location","title":"Location","text":"<ul> <li>NetBox Site to LibreNMS location synchronization</li> <li>Sync location latitude and longitude values from NetBoxx to LibreNMS</li> </ul>"},{"location":"feature_list/#interface-mapping","title":"Interface Mapping","text":"<ul> <li>Customizable LibreNMS to NetBox interface type mappings</li> <li>Interface Speed-based mapping rules</li> <li>Bulk import support</li> </ul>"},{"location":"development/","title":"Overview","text":""},{"location":"development/#development-guide-navigating-the-codebase","title":"Development Guide: Navigating the Codebase","text":"<p>This guide is intended for developers and contributors working on the NetBox LibreNMS Plugin. It provides a broad overview of the codebase structure and key elements. For detailed NetBox plugin development documentation, see the official NetBox documentation.</p>"},{"location":"development/#contents","title":"Contents","text":"<ul> <li>Project Structure: Overview of the main folders and files in the plugin.</li> <li>Views &amp; Inheritance: How views are organized, inheritance patterns, and extension tips.</li> <li>Mixins: Reusable logic for views, including API access and caching.</li> <li>Templates: Template structure, conventions, and customization tips.</li> </ul>"},{"location":"development/mixins/","title":"Mixins","text":""},{"location":"development/mixins/#mixins","title":"Mixins","text":"<p>Mixins in <code>views/mixins.py</code> provide reusable logic to keep views clean and DRY (Don't Repeat Yourself). They are designed to be combined with Django or NetBox views to add specific behaviors or shared functionality. When adding new views, consider using or extending these mixins to maintain consistency and reduce code duplication.</p>"},{"location":"development/mixins/#key-mixins","title":"Key Mixins","text":"<p>LibreNMSAPIMixin</p> <ul> <li>Provides a <code>librenms_api</code> property for accessing the LibreNMS API from any view.</li> <li>Ensures a single instance of the API client is reused per view instance.</li> <li>Example usage: Add to views that need to fetch or sync data with LibreNMS.</li> </ul> <p>CacheMixin</p> <ul> <li>Supplies helper methods for generating cache keys related to objects and data types (e.g., ports, links).</li> <li>Useful for views that cache data fetched from LibreNMS to improve performance.</li> <li>Methods:<ul> <li><code>get_cache_key(obj, data_type=\"ports\")</code>: Returns a unique cache key for the object and data type.</li> <li><code>get_last_fetched_key(obj, data_type=\"ports\")</code>: Returns a cache key for tracking when data was last fetched.</li> </ul> </li> </ul>"},{"location":"development/mixins/#how-to-use-mixins","title":"How to Use Mixins","text":"<p>To use a mixin, simply add it to the inheritance list of your view class. For example:</p> <pre><code>from .mixins import LibreNMSAPIMixin, CacheMixin\n\nclass MyCustomView(LibreNMSAPIMixin, CacheMixin, SomeBaseView):\n    # ... your view logic ...\n</code></pre> <p>Mixins can be combined as needed. Place mixins before the main base view to ensure their methods and properties are available.</p>"},{"location":"development/structure/","title":"Project Structure","text":""},{"location":"development/structure/#project-structure","title":"Project Structure","text":"<p>This document provides an overview of the NetBox LibreNMS Plugin's codebase organization.</p>"},{"location":"development/structure/#main-directories","title":"Main Directories","text":"<ul> <li><code>netbox_librenms_plugin/</code> \u2014 Main plugin code</li> <li><code>views/</code> \u2014 Custom views for devices, mappings, VMs, etc.<ul> <li><code>base/</code> \u2014 Abstract base views for shared logic</li> <li><code>sync/</code> \u2014 Views for synchronization logic</li> </ul> </li> <li><code>models.py</code> \u2014 Database models</li> <li><code>forms.py</code> \u2014 Custom forms</li> <li><code>tables/</code> \u2014 Table definitions for UI</li> <li><code>templates/</code> \u2014 Custom templates<ul> <li><code>netbox_librenms_plugin/</code> \u2014 Main template directory</li> <li><code>inc/</code> \u2014 Shared template fragments (e.g., paginator)</li> </ul> </li> <li><code>api/</code> \u2014 API serializers, views, and URLs</li> <li><code>migrations/</code> \u2014 Django migrations</li> <li><code>utils.py</code> \u2014 Utility functions</li> <li><code>navigation.py</code> \u2014 Menu/navigation integration</li> <li><code>static/</code> \u2014 Static assets (JS, CSS)<ul> <li><code>netbox_librenms_plugin/</code> \u2014 Plugin-specific static files</li> <li><code>js/</code> \u2014 JavaScript files</li> </ul> </li> <li><code>tests/</code> \u2014 Test suite</li> <li><code>docs/</code> \u2014 Documentation</li> </ul>"},{"location":"development/templates/","title":"Templates","text":""},{"location":"development/templates/#templates","title":"Templates","text":"<p>Templates are located in <code>templates/netbox_librenms_plugin/</code> and follow NetBox's conventions, using Django's template language. The plugin uses a combination of base templates, partials, and includes to keep the UI modular and maintainable.</p>"},{"location":"development/templates/#structure-and-conventions","title":"Structure and Conventions","text":"<ul> <li>Base templates (e.g., <code>librenms_sync_base.html</code>, <code>interfacetypemapping.html</code>) typically extend NetBox's generic templates (like <code>generic/object.html</code> or <code>generic/object_list.html</code>).</li> <li>Partials and includes (e.g., <code>_interface_sync.html</code>, <code>_interface_sync_content.html</code>, <code>_cable_sync.html</code>) are used for reusable UI components and AJAX/HTMX content updates.</li> <li>The <code>inc/</code> directory contains shared fragments, such as pagination controls (<code>paginator.html</code>).</li> </ul>"},{"location":"development/templates/#customization-and-inheritance","title":"Customization and Inheritance","text":"<ul> <li>Use the Django template tag <code>extends</code> to build on top of NetBox or plugin base templates, and the <code>block</code> tag to override or inject content.</li> <li>Use the Django template tag <code>include</code> for reusable sections (e.g., tables, forms, or modal dialogs).</li> <li>Static assets (JS/CSS) are loaded with the Django template tag <code>load static</code> and referenced using the <code>static</code> tag.</li> <li>Context variables and template tags (e.g., <code>helpers</code>, <code>plugins</code>, <code>render_table</code>) are used to render dynamic content and integrate with NetBox features.</li> </ul>"},{"location":"development/templates/#examples","title":"Examples","text":"<p>Sync Views:</p> <ul> <li><code>librenms_sync_base.html</code> provides the main layout for device/VM sync pages, extending NetBox's object template and including custom blocks for status, actions, and content.</li> <li><code>_interface_sync.html</code> and <code>_interface_sync_content.html</code> are used for the interface sync tab, supporting dynamic updates and user actions (like syncing selected interfaces).</li> </ul> <p>Mapping Views:</p> <ul> <li><code>interfacetypemapping.html</code> and <code>interfacetypemapping_list.html</code> display and manage interface type mappings, using table layouts and info alerts.</li> </ul> <p>For more on NetBox's template system, see the NetBox documentation.</p>"},{"location":"development/testing/","title":"Testing","text":""},{"location":"development/testing/#testing-guide","title":"Testing Guide","text":"<p>This guide explains how to run the test suite, write new tests, and debug failures.</p>"},{"location":"development/testing/#quick-start","title":"Quick Start","text":"<p>Run all tests with a single command:</p> <pre><code>make unittest\n</code></pre> <p>Or run pytest directly:</p> <pre><code>pytest netbox_librenms_plugin/tests/ -v\n</code></pre>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>The test suite covers all major plugin functionality. Tests are organized by the module they verify:</p> Test File What It Tests test_librenms_api.py LibreNMS API client\u2014connections, device operations, locations, ports, and error handling test_import_utils.py Device import logic\u2014filtering, validation, and data transformation test_import_validation_helpers.py Field validation for sites, roles, platforms, and device types test_utils.py General utilities\u2014name matching, speed conversion, and data formatting test_background_jobs.py Background job execution and view decision logic <p>Supporting files:</p> File Purpose conftest.py Shared pytest fixtures test_librenms_api_helpers.py Auto-use fixture for API configuration mocking"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#running-specific-tests","title":"Running Specific Tests","text":"<pre><code># Run a specific test file\npytest netbox_librenms_plugin/tests/test_librenms_api.py -v\n\n# Run a specific test class\npytest netbox_librenms_plugin/tests/test_librenms_api.py::TestLibreNMSAPIConnection -v\n\n# Run a specific test method\npytest netbox_librenms_plugin/tests/test_librenms_api.py::TestLibreNMSAPIConnection::test_connection_success -v\n</code></pre>"},{"location":"development/testing/#running-tests-by-area","title":"Running Tests by Area","text":"<pre><code># API client tests\npytest netbox_librenms_plugin/tests/test_librenms_api.py -v\n\n# Import and validation tests\npytest netbox_librenms_plugin/tests/test_import_utils.py netbox_librenms_plugin/tests/test_import_validation_helpers.py netbox_librenms_plugin/tests/test_utils.py -v\n\n# Background job tests\npytest netbox_librenms_plugin/tests/test_background_jobs.py -v\n</code></pre>"},{"location":"development/testing/#debugging-failed-tests","title":"Debugging Failed Tests","text":"<pre><code># Show full traceback\npytest netbox_librenms_plugin/tests/ -v --tb=long\n\n# Show print statements during tests\npytest netbox_librenms_plugin/tests/ -v -s\n\n# Stop on first failure\npytest netbox_librenms_plugin/tests/ -v -x\n\n# Re-run only failed tests from last run\npytest netbox_librenms_plugin/tests/ -v --lf\n</code></pre>"},{"location":"development/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>The test suite prioritizes speed and isolation so you can run tests frequently during development:</p> <ul> <li>Mock-based: Tests use <code>MagicMock</code> instead of real database objects. No Django database setup required.</li> <li>Fast execution: The full suite runs in under 0.5 seconds.</li> <li>Isolated: Each test is independent with no shared state between tests.</li> <li>No external dependencies: Tests don't make network calls or require LibreNMS access.</li> </ul> <p>This approach means tests work identically in your local development environment, in the devcontainer, and in CI pipelines.</p>"},{"location":"development/testing/#writing-new-tests","title":"Writing New Tests","text":""},{"location":"development/testing/#basic-test-template","title":"Basic Test Template","text":"<p>New tests should follow this structure:</p> <pre><code>from unittest.mock import MagicMock, patch\n\n\nclass TestFeatureName:\n    \"\"\"Tests for [feature description].\"\"\"\n\n    pytest_plugins = [\"tests.test_librenms_api_helpers\"]\n\n    @patch(\"netbox_librenms_plugin.module_name.external_dependency\")\n    def test_specific_behavior(self, mock_dependency, mock_librenms_config):\n        \"\"\"Describe what this test verifies.\"\"\"\n        # Arrange - set up test data and mocks\n        mock_dependency.return_value = {\"expected\": \"response\"}\n\n        # Act - call the code being tested\n        from netbox_librenms_plugin.module_name import function_to_test\n        result = function_to_test(input_data)\n\n        # Assert - verify the results\n        assert result == expected_value\n        mock_dependency.assert_called_once_with(expected_args)\n</code></pre>"},{"location":"development/testing/#key-testing-conventions","title":"Key Testing Conventions","text":"<p>Use inline imports inside test methods to avoid Django initialization at module load time:</p> <pre><code>def test_something(self):\n    from netbox_librenms_plugin.librenms_api import LibreNMSAPI\n    api = LibreNMSAPI(server_key=\"default\")\n</code></pre> <p>Mock NetBox models with <code>MagicMock()</code> instead of creating real database objects:</p> <pre><code>device = MagicMock()\ndevice.name = \"test-device\"\ndevice.primary_ip.address.ip = \"192.168.1.1\"\n</code></pre> <p>Patch at the source module, not where the function is imported:</p> <pre><code># Correct - patch where the function is defined\n@patch(\"netbox_librenms_plugin.import_utils.process_device_filters\")\n\n# Incorrect - patching the import location\n@patch(\"netbox_librenms_plugin.views.imports.list.process_device_filters\")\n</code></pre>"},{"location":"development/testing/#available-fixtures","title":"Available Fixtures","text":"<p>These fixtures are defined in conftest.py:</p> <ul> <li><code>mock_librenms_config</code> \u2014 Automatically mocks plugin configuration for all tests</li> <li><code>mock_response_factory</code> \u2014 Factory for creating mock HTTP responses</li> <li><code>mock_netbox_device</code> \u2014 Pre-configured mock NetBox Device object</li> <li><code>mock_netbox_vm</code> \u2014 Pre-configured mock NetBox VM object</li> </ul>"},{"location":"development/testing/#common-assertion-patterns","title":"Common Assertion Patterns","text":"<pre><code># Methods returning (success, data) tuples\nsuccess, data = api.get_device_info(123)\nassert success is True\nassert data[\"hostname\"] == \"expected-hostname\"\n\n# Methods returning dicts with error flags\nresult = api.test_connection()\nassert \"error\" not in result\n\n# Verifying exceptions are raised\nwith pytest.raises(ValueError, match=\"Invalid configuration\"):\n    api.method_that_should_fail()\n\n# Verifying mock calls\nmock_get.assert_called_once()\nmock_post.assert_called_with(expected_url, headers=expected_headers, json=expected_data)\nmock_delete.assert_not_called()\n</code></pre>"},{"location":"development/testing/#cicd-compatibility","title":"CI/CD Compatibility","text":"<p>The tests run in any environment without external dependencies:</p> <ul> <li>No database connection required</li> <li>No network access needed</li> <li>Fast execution suitable for pre-commit hooks</li> <li>Clear failure messages for debugging</li> <li>Works in containerized environments</li> </ul> <p>This makes the test suite suitable for GitHub Actions, pre-commit hooks, or any CI pipeline you choose to implement.</p>"},{"location":"development/views/","title":"Views & Inheritance","text":""},{"location":"development/views/#views-inheritance","title":"Views &amp; Inheritance","text":"<p>Views are organized by resource type (e.g., devices, mappings, VMs) in the <code>views/</code> directory. The codebase uses a layered approach to views, leveraging inheritance and mixins to maximize code reuse and maintainability.</p>"},{"location":"development/views/#view-organization","title":"View Organization","text":"<p>Resource-specific views:</p> <ul> <li>Device and VM sync tabs live under <code>object_sync/</code> (see <code>object_sync/devices.py</code> and <code>object_sync/vms.py</code>), while mappings/settings/status views remain as individual modules alongside the package.</li> <li>The LibreNMS import workflow is grouped under <code>views/imports/</code>: <code>list.py</code> renders the main table view and <code>actions.py</code> contains the HTMX endpoints (preview, validation, bulk execute). All legacy handlers formerly in <code>librenms_import_views.py</code> and <code>device_import_views.py</code> were folded into this package.</li> </ul> <p>Base views:</p> <ul> <li>The <code>base/</code> subdirectory contains abstract base views (e.g., <code>BaseLibreNMSSyncView</code>, <code>BaseInterfaceTableView</code>) that encapsulate shared logic for related resources.</li> </ul> <p>Mixins:</p> <ul> <li>Shared behaviors (e.g., API access, caching) are factored into mixins in <code>mixins.py</code> and combined with base or resource-specific views as needed.</li> </ul>"},{"location":"development/views/#inheritance-patterns","title":"Inheritance Patterns","text":"<ul> <li>Most resource-specific views inherit from a base view in <code>base/</code> and one or more mixins.</li> <li>Base views themselves often inherit from NetBox or Django generic views (e.g., <code>generic.ObjectListView</code>, <code>django.views.View</code>).</li> <li>This allows resource-specific views to override or extend only the methods they need, while inheriting default behaviors from base classes and mixins.</li> </ul>"},{"location":"development/views/#example-device-sync-view","title":"Example: Device Sync View","text":"<pre><code>from .base.librenms_sync_view import BaseLibreNMSSyncView\nfrom .mixins import LibreNMSAPIMixin\n\nclass DeviceLibreNMSSyncView(BaseLibreNMSSyncView):\n    # Inherits API access and sync logic from base/mixins\n    # Only device-specific logic needs to be implemented here\n    ...\n</code></pre>"},{"location":"development/views/#example-interface-table-view","title":"Example: Interface Table View","text":"<pre><code>from .base.interfaces_view import BaseInterfaceTableView\nfrom .mixins import CacheMixin, LibreNMSAPIMixin\n\nclass DeviceInterfaceTableView(BaseInterfaceTableView):\n    model = Device\n    # Implements get_interfaces and get_redirect_url for devices\n    ...\n</code></pre>"},{"location":"development/views/#customizing-or-adding-views","title":"Customizing or Adding Views","text":"<ul> <li>To add a new view for a resource, inherit from the relevant base view and mixins, then override or extend methods as needed.</li> <li>Use the base views as templates for structure and required methods.</li> <li>Register new views in <code>urls.py</code> and add templates if needed.</li> </ul>"},{"location":"development/views/#tips","title":"Tips","text":"<ul> <li>Check the <code>base/</code> directory for reusable logic before writing new view code.</li> <li>Use mixins for cross-cutting concerns (API, caching, permissions).</li> <li>Keep resource-specific views focused on their unique logic; delegate shared logic to base classes and mixins.</li> </ul>"},{"location":"librenms_import/background_jobs/","title":"Background Jobs & Caching","text":""},{"location":"librenms_import/background_jobs/#background-jobs-caching","title":"Background Jobs &amp; Caching","text":"<p>The Device Import feature uses background job processing and intelligent caching for both searching and importing devices. Background jobs are enabled by default for both operations to handle large device sets efficiently.</p>"},{"location":"librenms_import/background_jobs/#background-jobs","title":"Background Jobs","text":"<p>Background jobs run asynchronously in NetBox's job system for both device searches and import operations.</p>"},{"location":"librenms_import/background_jobs/#background-job-processing","title":"Background Job Processing","text":"<p>Both device searches and import operations can run as background jobs (default) or synchronously. Background jobs are recommended for:</p> <ul> <li>Large device sets (especially searches with more than 50 devices)</li> <li>Operations with Virtual Chassis detection enabled</li> <li>Import operations of any size</li> </ul> <p>Benefits of background jobs: - Avoid browser timeouts on long-running operations - Cancel operations in progress if needed - Continue using NetBox while the job runs - Review detailed logs and results after completion</p>"},{"location":"librenms_import/background_jobs/#viewing-job-status","title":"Viewing Job Status","text":"<p>All background jobs appear in NetBox's Jobs interface, where you can view status, start time, duration, and results.</p>"},{"location":"librenms_import/background_jobs/#caching","title":"Caching","text":"<p>The import table caches data for 5 minutes to reduce load times and minimize API calls to LibreNMS. Cache keys are unique per filter combination.</p>"},{"location":"librenms_import/background_jobs/#what-gets-cached","title":"What Gets Cached","text":"<p>The cache includes both LibreNMS device data AND NetBox reference data used in the import table:</p> <p>From LibreNMS: - Device lists matching your search filters - Device details (hostname, sysName, location, hardware, etc.) - Virtual chassis detection results</p> <p>From NetBox: - Available device roles (for the role dropdown in each row) - Available VM clusters (for VM imports) - Available racks for each site (filtered by the device's matched site)</p> <p>This means if you add a new role, create a new rack, or add a new cluster in NetBox, those changes won't appear in the import table dropdowns until you clear the cache or wait for it to expire (5 minutes).</p>"},{"location":"librenms_import/background_jobs/#controlling-cache","title":"Controlling Cache","text":"<p>The search form includes a \"Clear cache before search\" checkbox:</p> Setting Behavior Unchecked (default) Uses cached data if available. Fastest results. Checked Forces fresh data retrieval from both LibreNMS and NetBox. <p>When to clear cache: - After adding or updating devices in LibreNMS - After adding new roles, racks, or clusters in NetBox that should appear in import dropdowns - When troubleshooting import issues - When you need to verify current state</p> <p>When to keep cache enabled: - Normal operations and when refining search filters - When repeatedly working with the same set of devices - When NetBox reference data hasn't changed</p>"},{"location":"librenms_import/background_jobs/#active-cached-searches","title":"Active Cached Searches","text":"<p>The import page displays all your recent searches at the top, showing which filter combinations, that are still found in the cache. Each cached search shows the filters used, device count, and time remaining before expiration.</p> <p>Click any cached search to instantly reload those results without re-running filters or Virtual Chassis detection. This is particularly useful when switching between different filter combinations.</p> <p>Cached searches expire after 5 minutes of inactivity (or what you set as the cache timeout). The countdown timer shows how long each search remains available.</p> <p>The \"Clear cache before search\" option only clears the cache for the specific filter combination you're searching\u2014other cached searches remain available.</p>"},{"location":"librenms_import/import_process/","title":"Import process","text":""},{"location":"librenms_import/import_process/#import-settings","title":"Import Settings","text":"<p>Both single and bulk imports support these configuration options:</p>"},{"location":"librenms_import/import_process/#use-sysname","title":"Use sysName","text":"<p>When enabled (default): Uses the SNMP sysName as the device name in NetBox. Falls back to LibreNMS hostname if sysName is not available.</p> <p>When disabled: Uses the LibreNMS hostname field as the device name.</p> <p>Default: Controlled by Plugin Settings. Can be overridden per-import in the bulk import confirmation modal.</p>"},{"location":"librenms_import/import_process/#strip-domain","title":"Strip Domain","text":"<p>When enabled: Removes domain suffixes from device names. For example, \"router.example.com\" becomes \"router\". The plugin avoids stripping IP addresses.</p> <p>When disabled: Keeps the full name as-is.</p> <p>Default: Controlled by Plugin Settings. Can be overridden per-import in the bulk import confirmation modal.</p>"},{"location":"librenms_import/import_process/#device-name-examples","title":"Device Name Examples","text":"<pre><code>LibreNMS sysName: router-core-01.example.com\nLibreNMS hostname: 10.0.0.1\n\nUse sysName + Strip domain \u2192 \"router-core-01\"\nUse sysName + Keep domain \u2192 \"router-core-01.example.com\"\nUse hostname + Strip domain \u2192 \"10.0.0.1\" (IP preserved)\nUse hostname + Keep domain \u2192 \"10.0.0.1\"\n</code></pre> <p>If neither sysName nor hostname exists, the plugin generates a name as <code>device-{librenms_id}</code>.</p>"},{"location":"librenms_import/import_process/#what-gets-created-during-import","title":"What Gets Created During Import","text":"<p>When you import a device, the plugin creates several objects in NetBox:</p>"},{"location":"librenms_import/import_process/#device-or-virtualmachine-object","title":"Device or VirtualMachine Object","text":"<p>Created with these attributes:</p> <p>Required fields : Name, Site (devices only), Device Type (devices only), Device Role/VM Role, Cluster (VMs only)</p> <p>Optional fields : Platform, Serial number, Rack (devices only), Location (devices only)</p> <p>Note: When a rack is assigned during import, the device is placed in the rack but without a specific rack unit (U) position. After import, these devices appear in the \"Non racked\" section of the rack in NetBox. You'll need to manually assign U positions to organize devices within the rack. The NetBox Reorder Rack plugin can simplify this task.</p> <p>Status field : Set to \"active\" if LibreNMS shows device as up (status=1), \"offline\" otherwise</p> <p>Comments : Automatically includes import timestamp and source information</p> <p>Custom fields : <code>librenms_id</code> is set to the LibreNMS device ID for linking</p>"},{"location":"librenms_import/import_process/#virtual-chassis-if-detected","title":"Virtual Chassis (if detected)","text":"<p>For stackable devices with detected Virtual Chassis:</p> <p>Virtual Chassis object : Created with a name based on the master device and domain from VC data</p> <p>Master device assignment : The imported device is set as the master</p> <p>Member positions : Detected members are recorded with their positions, serials, and models for reference</p> <p>After import, you can use the standard Virtual Chassis features to add member devices and configure the stack fully.</p>"},{"location":"librenms_import/import_process/#librenms-integration","title":"LibreNMS Integration","text":"<p>The <code>librenms_id</code> custom field is automatically set, which enables: - Interface synchronization - Cable synchronization - IP address synchronization - Device field updates (serial, device type, platform)</p> <p>No additional configuration is needed\u2014these features become immediately available after import.</p>"},{"location":"librenms_import/import_process/#post-import-workflow","title":"Post-Import Workflow","text":"<p>After importing devices, typical next steps include:</p> <ol> <li>Review imported devices - Click the links in the success message to verify device details</li> <li>Assign rack positions - If devices were imported to a rack, assign specific U positions. The NetBox Reorder Rack plugin makes this process a lot easier.</li> <li>Sync interfaces - Navigate to the device in NetBox and use the LibreNMS sync button to pull interface data</li> <li>Sync cables - Once interfaces exist, sync cable connections from LibreNMS link data</li> <li>Sync IP addresses - Pull IP address assignments from LibreNMS to NetBox</li> </ol> <p>These sync operations use the <code>librenms_id</code> custom field that was automatically set during import.</p>"},{"location":"librenms_import/import_settings/","title":"Import Settings","text":""},{"location":"librenms_import/import_settings/#import-settings","title":"Import Settings","text":"<p>Configure how devices are named and what data is imported from LibreNMS to NetBox.</p>"},{"location":"librenms_import/import_settings/#setting-defaults","title":"Setting Defaults","text":"<p>To configure global defaults for all imports:</p> <ol> <li>Navigate to Plugins \u2192 LibreNMS Plugin \u2192 Settings</li> <li>Click Plugin Settings</li> <li>Configure Use sysName and Strip Domain to your preferred defaults</li> <li>Save changes</li> </ol> <p>These defaults apply to all future imports unless overridden during the import process.</p>"},{"location":"librenms_import/import_settings/#device-naming-options","title":"Device Naming Options","text":"<p>The plugin provides two settings that control how device names are created in NetBox. Both are configured in Plugin Settings under Plugins \u2192 LibreNMS Plugin \u2192 Settings \u2192 Plugin Settings and can be overridden on the LibreNMS import page.</p>"},{"location":"librenms_import/import_settings/#use-sysname","title":"Use sysName","text":"<p>Controls which field from LibreNMS becomes the device name in NetBox.</p> <ul> <li>Enabled (default): Uses the SNMP sysName, falling back to LibreNMS hostname if sysName is not available</li> <li>Disabled: Uses the LibreNMS hostname field</li> </ul>"},{"location":"librenms_import/import_settings/#strip-domain","title":"Strip Domain","text":"<p>Removes domain suffixes from device names to create shorter, cleaner names.</p> <ul> <li>Enabled: Removes domain suffixes (e.g., \"router.example.com\" becomes \"router\"). IP addresses are preserved without modification</li> <li>Disabled: Keeps the full name as-is</li> </ul>"},{"location":"librenms_import/import_settings/#naming-examples","title":"Naming Examples","text":"<pre><code>LibreNMS sysName: router-core-01.example.com\nLibreNMS hostname: 10.0.0.1\n\nUse sysName + Strip domain \u2192 \"router-core-01\"\nUse sysName + Keep domain \u2192 \"router-core-01.example.com\"\nUse hostname + Strip domain \u2192 \"10.0.0.1\" (IP preserved)\nUse hostname + Keep domain \u2192 \"10.0.0.1\"\n</code></pre> <p>If neither sysName nor hostname exists, the plugin generates a name as <code>device-{librenms_id}</code>.</p>"},{"location":"librenms_import/import_settings/#per-import-overrides","title":"Per-Import Overrides","text":"<p>When using bulk import, you can override the default settings in the confirmation modal before importing. This allows you to:</p> <ul> <li>Import some devices with sysName and others with hostname</li> <li>Apply domain stripping selectively based on device type or location</li> <li>Test different naming conventions before changing global defaults</li> </ul> <p>The override only affects the current import operation and doesn't change your saved defaults.</p>"},{"location":"librenms_import/overview/","title":"Overview","text":""},{"location":"librenms_import/overview/#device-import-overview","title":"Device Import Overview","text":"<p>The Device Import feature allows you to discover and import devices from LibreNMS into NetBox. This streamlines the process of populating NetBox with devices that are already monitored in LibreNMS, while giving you full control over how devices are imported.</p> <p>The import page should be clear and intuitive to use, but this overview provides additional context and details.</p>"},{"location":"librenms_import/overview/#how-it-works","title":"How It Works","text":"<p>The import workflow consists of three main steps:</p> <ol> <li>Search &amp; Filter - Find devices in LibreNMS using flexible filter criteria</li> <li>Review &amp; Validate - Validate import readiness and configure missing NetBox objects</li> <li>Import - Configure import settings and create devices in NetBox</li> </ol> <p>The plugin validates all required NetBox objects (Site, Device Type, Device Role) before allowing import.</p>"},{"location":"librenms_import/overview/#key-features","title":"Key Features","text":"<p>Flexible Filtering : Search by location, type, operating system, hostname, system name, or hardware model. Combine filters for precise device selection.</p> <p>Smart Validation : Automatic matching for Sites, Device Types, and Platforms based on LibreNMS data. Clear indicators for what's missing.</p> <p>Device or VM : Import as physical Devices (requires Site, Device Type, Role) or Virtual Machines (requires Cluster).</p> <p>Virtual Chassis Support : Automatic detection and creation of Virtual Chassis objects for stackable switches.</p> <p>Background Processing : Large device sets can be processed using NetBox background jobs with progress tracking and cancellation.</p>"},{"location":"librenms_import/overview/#accessing-the-feature","title":"Accessing the Feature","text":"<p>Navigate to the import interface through the NetBox menu:</p> <p>Plugins \u2192 LibreNMS Plugin \u2192 Import \u2192 LibreNMS Import</p> <p>This opens the device import page where you can search for and import devices from your LibreNMS instance.</p>"},{"location":"librenms_import/overview/#what-gets-created","title":"What Gets Created","text":"<p>When a device is imported, the plugin creates:</p> <p>Device or VirtualMachine Object : With all validated attributes (name, site, device type, role, platform, serial, rack, etc.). Note that rack assignment places the device in the rack without setting a specific rack unit (U) position\u2014devices appear in the \"Non racked\" section and require manual U assignment.</p> <p>LibreNMS ID Custom Field : Automatically set to link the NetBox object to the LibreNMS device. This enables all other plugin features (interface sync, cable sync, etc.)</p> <p>Virtual Chassis (if detected) : For stackable devices, creates the Virtual Chassis object and assigns member positions based on detected inventory data.</p> <p>After import, devices appear in NetBox with a comment indicating they were imported by the plugin, including the import timestamp.</p>"},{"location":"librenms_import/overview/#multi-server-support","title":"Multi-Server Support","text":"<p>If your NetBox installation is configured with multiple LibreNMS servers, the import feature automatically uses the currently selected server from Plugin Settings.</p> <p>All imported devices are linked to the server used during import, allowing you to maintain devices from multiple LibreNMS instances in a single NetBox installation.</p>"},{"location":"librenms_import/overview/#next-steps","title":"Next Steps","text":"<p>Explore each step of the import workflow:</p> <ul> <li>Search for Devices - Learn about filters, matching rules, and search options</li> <li>Validation &amp; Configuration - Understand validation status and resolve issues</li> <li>Import Settings - Configure device naming and import options</li> <li>Background Jobs &amp; Caching - Job processing and performance optimization</li> </ul>"},{"location":"librenms_import/search/","title":"Searching for Devices","text":"<p>The import feature requires at least one filter to search for devices. This prevents accidentally loading thousands of devices and helps you work with focused device sets.</p>"},{"location":"librenms_import/search/#available-filters","title":"Available Filters","text":"<p>LibreNMS Location : Exact match by LibreNMS location ID. The dropdown shows all locations from your LibreNMS instance with their names and IDs.</p> <p>LibreNMS Type : Exact match by device type (network, server, storage, wireless, firewall, power, appliance, printer, loadbalancer, other).</p> <p>Operating System : Partial match by OS name. For example, \"ios\" matches \"cisco-ios\", \"ios-xe\", \"cisco-ios-xr\".</p> <p>LibreNMS Hostname : Partial match by the hostname or IP address used to add the device to LibreNMS.</p> <p>LibreNMS System Name : When used alone, performs an exact match on the SNMP sysName. When combined with other filters, performs a partial match.</p> <p>Hardware : Partial match by LibreNMS hardware model. For example, \"C9300\" matches devices with hardware like \"Cisco C9300-48P\".</p>"},{"location":"librenms_import/search/#additional-search-options","title":"Additional Search Options","text":"<p>Include Disabled Devices : When checked, includes devices marked as disabled in LibreNMS. By default, only active devices are shown.</p> <p>Include Virtual Chassis Detection : When checked, analyzes device inventory to detect stackable switches and chassis. This adds processing time but provides helpful information about multi-member devices. See Virtual Chassis for details.</p> <p>Clear cache before search : Forces the plugin to fetch fresh data from LibreNMS instead of using cached results. LibreNMS data is normally cached for 5 minutes to improve performance.</p> <p>Exclude Existing Devices : When checked, hides devices that already exist in NetBox. By default, all devices are shown including those already imported.</p>"},{"location":"librenms_import/search/#filter-matching-rules","title":"Filter Matching Rules","text":"<p>Understanding how filters work helps you get the right results:</p> <p>Exact Match Filters : Location, Type, and OS (when used alone) must match exactly as shown in LibreNMS.</p> <p>Partial Match Filters : Hostname, OS (with other filters), and System Name (with other filters) find devices containing your search text.</p> <p>Multiple Filters : All filters must match for a device to appear in results. Start with Location or Type to narrow results, then refine with additional filters.</p>"},{"location":"librenms_import/search/#filter-examples","title":"Filter Examples","text":"<p>Find all network devices in New York <pre><code>Location: New York\nType: network\n</code></pre></p> <p>Find Cisco devices <pre><code>Type: network\nOS: ios\n</code></pre></p> <p>Find specific hardware model at New York <pre><code>Location: New York\nHardware: C9300\nType: network\n</code></pre></p> <p>Find a specific device by name <pre><code>System Name: router-core-01.example.com\n</code></pre></p> <p>Find devices with \"F\" in hostname at New York with device type firewall <pre><code>Hostname: F\nLocation: New York\nType: firewall\n</code></pre></p>"},{"location":"librenms_import/search/#search-options","title":"Search Options","text":"<p>Run as background job : Enabled by default. Runs searches asynchronously, allowing you to track progress and cancel operations. Recommended for most use cases, especially with Virtual Chassis detection or large device sets. See Background Jobs &amp; Caching for details.</p> <p>Clear cache before search : Forces fresh data from LibreNMS instead of using cached results. LibreNMS data is normally cached for 5 minutes to improve performance. See Background Jobs &amp; Caching for caching details.</p>"},{"location":"librenms_import/search/#saved-cached-searches","title":"Saved Cached Searches","text":"<p>The import page displays all your recent searches at the top, showing which filter combinations, that are still found in the cache. Each cached search shows the filters used, device count, and time remaining before expiration.  Click any cached search to instantly reload those results without re-running filters. This is particularly useful when switching between different filter combinations.</p>"},{"location":"librenms_import/search/#next-steps","title":"Next Steps","text":"<p>After searching, proceed to: - Validation &amp; Configuration - Review and configure devices for import - Background Jobs &amp; Caching - Understand job processing and performance optimization</p>"},{"location":"librenms_import/validation/","title":"Validation & Configuration","text":""},{"location":"librenms_import/validation/#validation-configuration","title":"Validation &amp; Configuration","text":"<p>After searching, the import table displays devices with action buttons that reflect their validation status.</p>"},{"location":"librenms_import/validation/#validation-states","title":"Validation States","text":"<p>Import Button (Green) : Device is ready to import. All required fields are matched or configured.</p> <p>Disabled Import Button + Details Button (Gray/Red) : Device has missing required fields. Click Details to configure.</p> <p>Link to Existing Device : Device already exists in NetBox. Link navigates to the existing device.</p>"},{"location":"librenms_import/validation/#required-fields","title":"Required Fields","text":"<p>NetBox requires three fields before importing a device: Site, Device Type, and Device Role. The plugin attempts to match Site and Device Type automatically by comparing LibreNMS data to existing NetBox objects. Device Role must always be selected manually.</p> <p>Click the validation details button to review what's missing and select values from the dropdowns. The validation status updates immediately.</p>"},{"location":"librenms_import/validation/#import-as-device","title":"Import as Device","text":"<ul> <li>Site (required) - Auto-matched from LibreNMS location</li> <li>Device Type (required) - Auto-matched from LibreNMS hardware string</li> <li>Device Role (required) - Must be selected manually</li> <li>Platform (optional) - Auto-matched from LibreNMS OS</li> <li>Rack (optional) - Available if Site has racks</li> </ul>"},{"location":"librenms_import/validation/#import-as-virtual-machine","title":"Import as Virtual Machine","text":"<ul> <li>Cluster (required) - Must be selected manually</li> <li>Platform (optional) - Auto-matched from LibreNMS OS</li> </ul>"},{"location":"librenms_import/validation/#virtual-chassis-detection","title":"Virtual Chassis Detection","text":"<p>When Virtual Chassis Detection is enabled during search, the validation details show detected stack members with their positions, serials, and suggested names. The plugin automatically creates the Virtual Chassis object during import. See Virtual Chassis for details.</p>"},{"location":"librenms_import/validation/#duplicate-detection","title":"Duplicate Detection","text":"<p>The plugin checks for existing devices using:</p> <ol> <li>LibreNMS ID custom field (most reliable) - If set, device is marked \"Already Exists\"</li> <li>Hostname match - Exact name match against Devices and VMs</li> <li>Primary IP address (weak match) - If IP is already assigned to a device</li> </ol> <p>If both a VM and Device with the same hostname exist, the plugin cannot determine which to match and allows import. Set the <code>librenms_id</code> custom field on the correct existing object to clarify the match.</p>"},{"location":"librenms_import/validation/#next-steps","title":"Next Steps","text":"<ul> <li>Import Settings - Configure device naming and import options</li> </ul>"},{"location":"usage_tips/","title":"Initial Setup","text":""},{"location":"usage_tips/#usage-tips","title":"Usage Tips","text":""},{"location":"usage_tips/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Configure Custom Field</p> <ul> <li>Set up the <code>librenms_id</code> custom field for optimal device matching</li> <li>This ensures reliable device identification between NetBox and LibreNMS</li> </ul> </li> <li> <p>Configure Interface Mappings</p> <ul> <li>Review and set up interface type mappings before synchronization</li> <li>Create specific mappings for your network equipment types</li> <li>Pay attention to speed-based mappings for accurate interface types</li> </ul> </li> <li> <p>Multi Server Configuration</p> <ul> <li>Configure multiple LibreNMS instances in your NetBox configuration</li> <li>Switch between different LibreNMS servers through the web interface</li> <li>Maintain backward compatibility with single-server configurations</li> </ul> </li> </ol>"},{"location":"usage_tips/#device-import","title":"Device Import","text":"<p>Device Import Guide - Import devices from LibreNMS into NetBox</p> <ol> <li>Search for devices using flexible filters (location, type, OS, hostname, sysname)</li> <li>Validate import prerequisites (Site, Device Type, Device Role)</li> <li>Configure missing mappings or select from suggestions</li> <li>Import devices individually or in bulk</li> <li>Automatic Virtual Chassis creation for stackable switches</li> </ol> <p>The Device Import feature automatically sets the <code>librenms_id</code> custom field, enabling all other plugin features.</p> <p>Rack Position Assignment: Imported devices can be assigned to racks without specific rack unit (U) positions. After import, assign U positions through the \"Non racked\" section of each rack. The NetBox Reorder Rack plugin simplifies this workflow.</p>"},{"location":"usage_tips/#device-synchronization","title":"Device Synchronization","text":""},{"location":"usage_tips/#devices","title":"Devices","text":"<p>Note: If you imported devices using the Device Import feature, the <code>librenms_id</code> is already set and will be used automatically. The steps below apply to devices added to NetBox manually.</p> <ol> <li>Ensure devices have either:<ul> <li>Primary IP configured</li> <li>Valid DNS name (set on the Primary IP)</li> <li>hostname (that matches LibreNMS hostname)</li> </ul> </li> <li>The plugin will populate the <code>librenms_id</code> custom field if the device is found in LibreNMS</li> </ol>"},{"location":"usage_tips/#virtual-chassis","title":"Virtual Chassis","text":"<p>LibreNMS treats a Virtual Chassis as one logical device. The plugin selects a single \"sync device\" from your chassis to communicate with LibreNMS using this priority:</p> <ol> <li>Member with <code>librenms_id</code> set (if already configured)</li> <li>Master device with primary IP (most common)</li> <li>Any member with primary IP (fallback)</li> <li>Member with lowest position number (last resort)</li> </ol> <p>Only the selected sync device should have the <code>librenms_id</code> custom field populated\u2014leave it empty on all other members.</p> <p>For best results, align chassis member positions with interface naming patterns. For example, if switch 1 has interfaces like <code>eth1/0/1</code> and switch 2 has <code>eth2/0/1</code>, the plugin can auto-detect the correct member for each interface. Always verify the member selection before running bulk synchronization.</p>"},{"location":"usage_tips/#interface-management","title":"Interface Management","text":"<ol> <li>Verify Before Sync<ul> <li>Review interface mappings indicated by the icons (\ud83d\udd17 shows a mapping is configured)</li> <li>Check speed and type matches</li> <li>Confirm member assignments for virtual chassis</li> </ul> </li> <li>Exlude columns to exclude from interface sync<ul> <li>Sync only the values you want to sync</li> </ul> </li> </ol>"},{"location":"usage_tips/#cable-management","title":"Cable Management","text":"<ol> <li>Preparation<ul> <li>Ensure devices are properly identified in both systems</li> <li>Open LibreNMS Sync on all devices to populate librenms_id custom field</li> <li>Remote Device and Remote interface need to be found in NetBox for cable creation to work</li> <li>Check Device and Interface naming</li> </ul> </li> </ol>"},{"location":"usage_tips/#best-practices","title":"Best Practices","text":"<ol> <li>Regular Maintenance<ul> <li>Periodically review and update interface mappings</li> <li>Keep custom fields current</li> </ul> </li> </ol>"},{"location":"usage_tips/#optimization","title":"Optimization","text":"<pre><code>- DNS lookup time can slow response of the API call to LibreNMS\n</code></pre>"},{"location":"usage_tips/custom_field/","title":"Custom Field Setup","text":""},{"location":"usage_tips/custom_field/#using-the-librenms_id-custom-field","title":"Using the <code>librenms_id</code> Custom Field","text":""},{"location":"usage_tips/custom_field/#overview","title":"Overview","text":"<p>To enhance device identification and synchronization between NetBox and LibreNMS, this plugin supports using a custom field <code>librenms_id</code> on Device, Virtual Machine and Interface objects. While the plugin works without it, using this custom field is recommended for LibreNMS API lookups, and to assist with matching the remote device and remote interfaces for cable creation in Netbox. It can also be entered manually if no primary IP or FQDN is available.</p> <p>For the Device and Virtual Machine objects the plugin will automatically populate the LibreNMS ID custom field when opening the LibreNMS Sync page if the device has been found in LibreNMS.</p> <p>For the Interface object, the plugin will automatically populate the LibreNMS ID custom field when the interface data is synced from LibreNMS.</p>"},{"location":"usage_tips/custom_field/#benefits-of-using-librenms_id","title":"Benefits of Using <code>librenms_id</code>","text":"<ul> <li>Improved Device Matching: Ensures accurate matching between NetBox and LibreNMS devices.</li> <li>Fallback Identification: Useful when devices lack a primary IP or FQDN.</li> <li>Efficient Synchronization: Enhances the reliability of API lookups.</li> <li>Cable creation: Allows better device identification for the creation of cables between NetBox devices.</li> </ul>"},{"location":"usage_tips/custom_field/#suggested-custom-field-setup","title":"Suggested Custom Field Setup","text":"<p>Follow these steps to create the <code>librenms_id</code> custom field in NetBox:</p> <ol> <li> <p>Navigate to Custom Fields:</p> <ul> <li>Go to Customization in the NetBox sidebar.</li> <li>Click on Custom Fields.</li> </ul> </li> <li> <p>Add a New Custom Field:</p> <ul> <li>Click the Add a custom field button.</li> </ul> </li> <li> <p>Configure the Custom Field:</p> <ul> <li>Object Types: <ul> <li>Check dcim &gt; device</li> <li>Check virtualization &gt; virtual machine</li> <li>Check dcim &gt; interface</li> <li>Check virtualization &gt; interfaces (optional)</li> </ul> </li> <li>Name: <code>librenms_id</code></li> <li>Label: <code>LibreNMS ID</code></li> <li>Description: (Optional) Add a description like \"LibreNMS Device ID for synchronization\".</li> <li>Type: Integer</li> <li>Required: Leave unchecked (optional).</li> <li>Default Value: Leave blank.</li> </ul> </li> <li> <p>Save the Custom Field:</p> <ul> <li>Click Create to save the custom field.</li> </ul> </li> </ol>"},{"location":"usage_tips/custom_field/#manually-assign-a-value-to-librenms_id","title":"Manually assign a value to <code>librenms_id</code>","text":"<p>You can manually assign a value to the <code>librenms_id</code> custom field for a device using the following steps:</p> <ol> <li> <p>Edit the Device:</p> <ul> <li>Navigate to the device in NetBox.</li> <li>Click the Edit button.</li> </ul> </li> <li> <p>Set the LibreNMS ID:</p> <ul> <li>Scroll to the Custom Fields section.</li> <li>Enter the LibreNMS device ID in the <code>librenms_id</code> field.</li> </ul> </li> <li> <p>Save Changes:</p> <ul> <li>Click Update to save the device.</li> </ul> </li> </ol>"},{"location":"usage_tips/custom_field/#notes","title":"Notes","text":"<ul> <li>If <code>librenms_id</code> is set, the plugin will prioritize it over other identification methods.</li> <li>Ensure the <code>librenms_id</code> corresponds to the correct device ID in LibreNMS to prevent mismatches.</li> <li>The custom field is optional but recommended for optimal plugin performance.</li> <li>Using the custom field on interfaces will greatly improve the interface matching required for cable creation.</li> </ul>"},{"location":"usage_tips/interface_mappings/","title":"Interface Mappings","text":""},{"location":"usage_tips/interface_mappings/#interface_mappings","title":"interface_mappings","text":""},{"location":"usage_tips/interface_mappings/#quick-intro","title":"Quick Intro","text":"<p>Interface type mappings control how LibreNMS interface types are translated to NetBox interface types during synchronization.</p> <p>The mappings can be customized in the plugin settings menu.</p> <p>A mapping of LibreNMS Type an LibreNMS Speed combine to make a unique group that map to a Netbox interface type. This means multiple mapping for the same LibreNMS Type can be created.</p> <p>Note: The LibreNMS Speed is entered as Kbps</p> <p>Example:</p> <pre><code>* ethernetCsmacd + 10000000 = 10GBASE-T (10GE)\n* ethernetCsmacd + 1000000 = 1000BASE-T (1GE)\n* ethernetCsmacd + 100000 = 100BASE-TX (10/100ME)\n</code></pre>"},{"location":"usage_tips/interface_mappings/#how-to-use-interface-mappings","title":"How to Use Interface Mappings","text":""},{"location":"usage_tips/interface_mappings/#accessing-the-page","title":"Accessing the Page:","text":"<ul> <li>From the main menu, navigate to the Plugins section</li> <li>Under Netbox Librenms Plugin, Select \"Interface Mappings\"</li> </ul>"},{"location":"usage_tips/interface_mappings/#creating-a-new-mapping","title":"Creating a New Mapping:","text":"<ul> <li>Click the green <code>+</code> or <code>Add</code> button either from the menu or on the Interface Mappings page</li> <li>Enter LibreNMS interface type. You can copy this from plugin's device interface sync page</li> <li>Enter Librenms interface speed as Kbps</li> <li>Select the Netbox interface type from the dropdown</li> <li>Click <code>Create</code> to save the mapping</li> </ul>"},{"location":"usage_tips/interface_mappings/#bulk-importing-mappings","title":"Bulk Importing Mappings:","text":"<p>The plugin supports NetBox's standard bulk import feature for interface mappings. Click the Import button on the Interface Mappings page to access the import interface.</p> <p>YAML Example:</p> <pre><code>---\n- librenms_type: ethernetCsmacd\n  librenms_speed: 1000000\n  netbox_type: 1000base-t\n  description: \"Standard Gigabit Ethernet ports\"\n\n- librenms_type: propVirtual\n  librenms_speed: 1000000\n  netbox_type: virtual\n  description: \"Virtual interfaces with 1G speed\"\n\n- librenms_type: softwareLoopback\n  librenms_speed: 8000000\n  netbox_type: virtual\n  description: \"Loopback interfaces\"\n\n- librenms_type: ethernetCsmacd\n  librenms_speed: 10000000\n  netbox_type: 10gbase-t\n  description: \"10 Gigabit Ethernet copper connections\"\n\n- librenms_type: ethernetCsmacd\n  librenms_speed: 100000\n  netbox_type: 100base-tx\n  description: \"Fast Ethernet 100Mbps ports\"\n\n- librenms_type: ethernetCsmacd\n  librenms_speed: null\n  netbox_type: 1000base-t\n  description: \"Default mapping for Ethernet without speed detection\"\n\n- librenms_type: ethernetCsmacd\n  librenms_speed: 40000000\n  netbox_type: 40gbase-x-qsfpp\n  description: \"40 Gigabit QSFP+ interfaces\"\n\n- librenms_type: ethernetCsmacd\n  librenms_speed: 25000000\n  netbox_type: 25gbase-x-sfp28\n  description: \"25 Gigabit SFP28 interfaces\"\n\n- librenms_type: propVirtual\n  librenms_speed: null\n  netbox_type: virtual\n  description: \"Generic virtual interfaces\"\n\n- librenms_type: ieee8023adLag\n  librenms_speed: null\n  netbox_type: lag\n  description: \"Link aggregation groups (port channels)\"\n\n- librenms_type: softwareLoopback\n  librenms_speed: null\n  netbox_type: virtual\n  description: \"Software loopback interfaces\"\n</code></pre> <p>Notes:</p> <ul> <li><code>librenms_speed</code> is optional - use <code>null</code> or omit for type-only mappings</li> <li><code>description</code> is optional - provides context for each mapping</li> <li>The combination of <code>librenms_type</code> and <code>librenms_speed</code> must be unique</li> <li>Supports CSV, JSON, and YAML formats</li> </ul>"},{"location":"usage_tips/interface_mappings/#editing-existing-mappings","title":"Editing Existing Mappings:","text":"<ul> <li>On the Mappings page, Locate the desired mapping in the list</li> <li>Click the <code>edit</code> (pencil icon) button</li> <li>Modify the field mappings as needed</li> <li>Save the changes</li> </ul>"},{"location":"usage_tips/interface_mappings/#deleting-mappings","title":"Deleting Mappings:","text":"<ul> <li>Find the mapping you wish to remove</li> <li>Select the <code>Delete</code> button from the drop down</li> <li>Confirm the deletion when prompted</li> </ul>"},{"location":"usage_tips/interface_mappings/#applying-mappings","title":"Applying Mappings:","text":"<ul> <li>Mappings are automatically applied when interface data is synced between LibreNMS and Netbox</li> <li>If a mapping exist for an interface, it will show on the interface sync page with the icon </li> <li>If a mapping does not exist, it will show the icon </li> </ul>"},{"location":"usage_tips/interface_mappings/#best-practices","title":"Best Practices","text":"<ul> <li>Check mappings are correct before performing a sync to avoid data errors</li> <li>Regularly review and update your mappings to ensure they remain accurate</li> </ul>"},{"location":"usage_tips/multi_server_configuration/","title":"Multi-Server Setup","text":""},{"location":"usage_tips/multi_server_configuration/#multi-server-librenms-configuration","title":"Multi-Server LibreNMS Configuration","text":""},{"location":"usage_tips/multi_server_configuration/#overview","title":"Overview","text":"<p>The NetBox LibreNMS plugin now supports multiple LibreNMS servers. This allows you to:</p> <ul> <li>Configure multiple LibreNMS instances in your NetBox configuration</li> <li>Switch between different LibreNMS servers through the web interface</li> <li>Maintain backward compatibility with single-server configurations</li> </ul>"},{"location":"usage_tips/multi_server_configuration/#configuration","title":"Configuration","text":""},{"location":"usage_tips/multi_server_configuration/#multi-server-configuration","title":"Multi-Server Configuration","text":"<p>Update your NetBox <code>configuration.py</code> file:</p> <pre><code>PLUGINS_CONFIG = {\n    'netbox_librenms_plugin': {\n        'servers': {\n            'production': {\n                'display_name': 'Production LibreNMS',\n                'librenms_url': 'https://librenms-prod.example.com',\n                'api_token': 'your_production_token',\n                'cache_timeout': 300,\n                'verify_ssl': True,\n                'interface_name_field': 'ifDescr'\n            },\n            'testing': {\n                'display_name': 'Test LibreNMS',\n                'librenms_url': 'https://librenms-test.example.com',\n                'api_token': 'your_test_token',\n                'cache_timeout': 300,\n                'verify_ssl': False,\n                'interface_name_field': 'ifName'\n            },\n            'development': {\n                'display_name': 'Dev LibreNMS',\n                'librenms_url': 'https://librenms-dev.example.com',\n                'api_token': 'your_dev_token',\n                'cache_timeout': 180,\n                'verify_ssl': False,\n                'interface_name_field': 'ifDescr'\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"usage_tips/multi_server_configuration/#legacy-single-server-configuration-backward-compatible","title":"Legacy Single-Server Configuration (Backward Compatible)","text":"<p>The original configuration format is still supported:</p> <pre><code>PLUGINS_CONFIG = {\n    'netbox_librenms_plugin': {\n        'librenms_url': 'https://your-librenms-instance.com',\n        'api_token': 'your_librenms_api_token',\n        'cache_timeout': 300,\n        'verify_ssl': True,\n        'interface_name_field': 'ifDescr'\n    }\n}\n</code></pre>"},{"location":"usage_tips/multi_server_configuration/#usage","title":"Usage","text":"<ol> <li>Navigate to LibreNMS Plugin &gt; Settings &gt; Server Settings</li> <li>Select your desired LibreNMS server from the dropdown</li> <li>Click Save Settings</li> </ol> <p>All subsequent LibreNMS operations will use the selected server.</p>"},{"location":"usage_tips/multi_server_configuration/#configuration-options","title":"Configuration Options","text":"<p>Each server configuration supports the following options:</p> <ul> <li><code>display_name</code>: Human-readable name for the server (optional)</li> <li><code>librenms_url</code>: URL of the LibreNMS instance (required)</li> <li><code>api_token</code>: API token for authentication (required)</li> <li><code>cache_timeout</code>: Cache timeout in seconds (optional, default: 300)</li> <li><code>verify_ssl</code>: Whether to verify SSL certificates (optional, default: True)</li> <li><code>interface_name_field</code>: LibreNMS field for interface names (optional, default: 'ifDescr')</li> </ul>"},{"location":"usage_tips/multi_server_configuration/#migration-from-single-to-multi-server","title":"Migration from Single to Multi-Server","text":"<ol> <li>Add the <code>servers</code> configuration block to your <code>configuration.py</code></li> <li>Move your existing single-server configuration into a server block (e.g., 'default' or 'production')</li> <li>Restart NetBox</li> <li>Select your server in the plugin settings</li> </ol> <p>The plugin will automatically detect and use the new configuration format.</p>"},{"location":"usage_tips/suggested_workflow/","title":"Suggested Workflow","text":""},{"location":"usage_tips/suggested_workflow/#suggested-workflow","title":"Suggested Workflow","text":"<p>This guide provides a recommended workflow for using the plugin after installation. Following this order helps ensure smooth operation and avoids common issues.</p>"},{"location":"usage_tips/suggested_workflow/#1-configure-plugin-settings","title":"1. Configure Plugin Settings","text":"<p>Navigate to Plugins \u2192 LibreNMS Plugin \u2192 Settings and configure:</p> <ul> <li>LibreNMS Server: Select which server to use (if multi-server setup)</li> <li>Device Naming: Set your preferred defaults for \"Use sysName\" and \"Strip Domain\" - see Import Settings</li> <li>Virtual Chassis Naming: Configure the member naming pattern if you plan to import stackable devices</li> </ul> <p>Why first: These defaults apply to all imports and save time by reducing per-import configuration.</p>"},{"location":"usage_tips/suggested_workflow/#2-create-custom-field","title":"2. Create Custom Field","text":"<p>Create the <code>librenms_id</code> custom field in NetBox following the Custom Field Setup guide.</p> <p>Why early: This field enables the most reliable device matching and is required for interface, cable, and IP address synchronization features. Creating it before importing prevents issues with duplicate device detection.</p>"},{"location":"usage_tips/suggested_workflow/#3-prepare-netbox-data","title":"3. Prepare NetBox Data","text":"<p>Ensure NetBox has the basic objects needed for device imports:</p> <ul> <li>Sites: Create Sites that match your LibreNMS locations (exact name matching works best)</li> <li>Device Types: Add Device Types for your common hardware models</li> <li>Device Roles: Create appropriate roles (Switch, Router, Firewall, etc.)</li> <li>Platforms: Add Platforms matching your LibreNMS OS names (optional but helpful)</li> </ul> <p>Why before importing: The plugin auto-matches these objects during import. Pre-creating them reduces manual configuration during the import process.</p>"},{"location":"usage_tips/suggested_workflow/#4-configure-interface-mappings","title":"4. Configure Interface Mappings","text":"<p>If you have specific interface type mapping requirements, configure them via Plugins \u2192 LibreNMS Plugin \u2192 Interface Type Mappings - see Interface Mappings.</p> <p>Why: Ensure specific NetBox interface types are used for your LibreNMS interface data.</p>"},{"location":"usage_tips/suggested_workflow/#5-import-devices","title":"5. Import Devices","text":"<p>Use the Device Import feature to bring devices into NetBox:</p> <ol> <li>Navigate to Plugins \u2192 LibreNMS Plugin \u2192 Import \u2192 LibreNMS Import</li> <li>Apply filters to find devices (start with Location or Type)</li> <li>Review validation status and configure missing fields</li> <li>Import devices individually or in bulk</li> </ol> <p>Tips:</p> <ul> <li>Start with a small set (single location or device type) to verify your setup</li> <li>Enable Virtual Chassis detection only when importing stackable switches</li> </ul>"},{"location":"usage_tips/suggested_workflow/#6-sync-interfaces","title":"6. Sync Interfaces","text":"<p>After devices are imported, sync their interfaces:</p> <ol> <li>Navigate to a device in NetBox</li> <li>Use the LibreNMS sync button to pull interface data</li> <li>Review and adjust Interface Mappings if needed</li> </ol> <p>Why after import: Interfaces require the device to exist in NetBox first. The <code>librenms_id</code> field set during import enables accurate synchronization.</p>"},{"location":"usage_tips/suggested_workflow/#7-sync-cables-and-ip-addresses","title":"7. Sync Cables and IP Addresses","text":"<p>Complete your device data by syncing:</p> <ul> <li>Cables: Pull link data from LibreNMS to create cable connections</li> <li>IP Addresses: Import IP assignments to populate NetBox's IPAM</li> </ul> <p>Why last: Both features require that interfaces already exist in NetBox and ideally with the <code>librenms_id</code> field set. The <code>librenms_id</code> field on interfaces ensures accurate matching.</p>"},{"location":"usage_tips/suggested_workflow/#8-sync-locations-optional","title":"8. Sync Locations (Optional)","text":"<p>If you want to synchronize location latitude/longitude data between NetBox Sites and LibreNMS locations, use the location sync feature.</p> <p>Why optional: Only needed if you maintain geographic coordinates and want bidirectional sync.</p>"},{"location":"usage_tips/suggested_workflow/#next-steps","title":"Next Steps","text":"<p>After completing the initial workflow:</p> <ul> <li>Regular imports: Use the same import process for new devices as they're added to LibreNMS</li> <li>Interface updates: Re-sync interfaces periodically to capture configuration changes</li> <li>Virtual Chassis: See Virtual Chassis for managing multi-member devices</li> <li>Background Jobs: Understand Background Jobs &amp; Caching for performance optimization</li> </ul>"},{"location":"usage_tips/virtual_chassis/","title":"Virtual Chassis","text":""},{"location":"usage_tips/virtual_chassis/#virtual-chassis-support","title":"Virtual Chassis Support","text":""},{"location":"usage_tips/virtual_chassis/#overview","title":"Overview","text":"<p>The plugin automatically detects Virtual Chassis configurations and displays all VC interfaces on the LibreNMS Sync page of the designated sync device.</p> <p>LibreNMS Sync Device Selection Priority: 1. Member with <code>librenms_id</code> custom field (highest priority) 2. Master device with primary IP 3. Any member with primary IP 4. Member with lowest VC position</p> <p>Note: LibreNMS treats a Virtual Chassis as a single logical device. Only one member (the sync device) should have the <code>librenms_id</code> custom field set.</p>"},{"location":"usage_tips/virtual_chassis/#how-it-works","title":"How It Works","text":""},{"location":"usage_tips/virtual_chassis/#member-selection","title":"Member Selection","text":"<p>When viewing a device that is part of a virtual chassis, the plugin will:</p> <ol> <li>Detects if the device is part of a virtual chassis and dispalys 'Virtual Chassis Member' column.</li> <li>Automatically select the VC member by matching the device VC position to the first number in the interface name.</li> <li>Allows selection of specific members if the auto select is not correct.</li> </ol> <p>Selecting a new member will trigger a new interface details comparison against the newly selected NEtbox VC member.</p> <p>Interfaces data is then synced to the selected VC member in Netbox.</p>"},{"location":"usage_tips/virtual_chassis/#virtual-chassis-member-select","title":"Virtual Chassis Member Select","text":""}]}